

// ===== controllers/adminController.js =====

import User from '../models/user.js';

// Get all users (Admin only)
export const getAllUsers = async (req, res) => {
  try {
    const users = await User.find().select('-password'); // Exclude password
    res.status(200).json(users);
  } catch (err) {
    res.status(500).json({ error: 'Failed to fetch users' });
  }
};

// Update a user by ID (Admin only)
export const updateUser = async (req, res) => {
  const { id } = req.params;
  const { name, email, role } = req.body;

  try {
    const updatedUser = await User.findByIdAndUpdate(
      id,
      { name, email, role },
      { new: true, runValidators: true }
    ).select('-password');

    if (!updatedUser) {
      return res.status(404).json({ error: 'User not found' });
    }

    res.status(200).json(updatedUser);
  } catch (err) {
    res.status(500).json({ error: 'Failed to update user' });
  }
};

// Delete a user by ID (Admin only)
export const deleteUser = async (req, res) => {
  const { id } = req.params;

  try {
    const deletedUser = await User.findByIdAndDelete(id);

    if (!deletedUser) {
      return res.status(404).json({ error: 'User not found' });
    }

    res.status(200).json({ message: 'User deleted successfully' });
  } catch (err) {
    res.status(500).json({ error: 'Failed to delete user' });
  }
};


// ===== controllers/auth.js =====

import jwt from 'jsonwebtoken';

export const login = async (req, res) => {
  const { email, password } = req.body;
  const user = await User.findOne({ email });

  // password check skipped for brevity

  const token = jwt.sign(
    { id: user._id, role: user.role },     // payload
    process.env.JWT_SECRET,               // secret key
    { expiresIn: '7d' }                   // optional: token expiry
  );

  res.status(200).json({
    token,
    role: user.role,
    user: { id: user._id, name: user.name }
  });
};


// ===== controllers/authController.js =====

// controllers/authController.js
import User from '../models/user.js';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';

export const register = async (req, res) => {
  const { name, email, password, role } = req.body;

  try {
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ error: 'Email already exists' });
    }

    const hashedPassword = await bcrypt.hash(password, 10);
    const user = await User.create({ name, email, password: hashedPassword, role });

    res.status(201).json({ message: 'Registration successful' });
  } catch (err) {
    console.error('Register error:', err.message); // âœ… Add this line for debugging
    res.status(500).json({ error: 'Server error' }); // âœ… Keep this response
  }
};



export const login = async (req, res) => {
  try {
    const { email, password } = req.body;

    if (!email || !password) {
      return res.status(400).json({ error: 'Email and password are required' });
    }

    const user = await User.findOne({ email });
    if (!user || !(await bcrypt.compare(password, user.password))) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    const token = jwt.sign(
      { id: user._id, role: user.role },
      process.env.JWT_SECRET,
      { expiresIn: '1d' }
    );

    res.status(200).json({
      message: 'Login successful',
      token
    });
  } catch (err) {
    console.error('Login error:', err); // ðŸ‘ˆ Helpful for debugging
    res.status(500).json({ error: 'Login failed' });
  }
};


// ===== controllers/generateResumeController.js =====

// controllers/generateResumeController.js
"use server";
import dotenv from "dotenv";
dotenv.config();
import PDFDocument from 'pdfkit';
import { OpenAI } from 'openai';

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

export const generateAndDownloadResume = async (req, res) => {
  const { name, email, skills, experience, education } = req.body;

  if (!name || !skills || !experience || !education) {
    return res.status(400).json({ error: 'Missing required fields' });
  }

  const prompt = `Create a professional resume for:
  Name: ${name}
  Email: ${email}
  Skills: ${skills.join(', ')}
  Experience: ${experience}
  Education: ${education}`;

  try {
    const completion = await openai.chat.completions.create({
      model: 'gpt-4',
      messages: [{ role: 'user', content: prompt }],
      temperature: 0.7,
    });

    const resumeText = completion.choices[0].message.content;

    const filename = `resume_${name.replace(/\s+/g, '_')}.pdf`;
    res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
    res.setHeader('Content-Type', 'application/pdf');

    const doc = new PDFDocument();
    doc.pipe(res);
    doc.fontSize(12).text(resumeText, { align: 'left' });
    doc.end();

  } catch (error) {
    console.error('Resume generation error:', error);
    res.status(500).json({ error: 'Failed to generate resume' });
  }
};


// ===== controllers/jobController.js =====

import Job from '../models/Job.js';

export const postJob = async (req, res) => {
  try {
    const job = await Job.create({ ...req.body, postedBy: req.user.id });
    res.status(201).json(job);
  } catch (err) {
    res.status(500).json({ error: 'Server error while posting job' });
  }
};

export const getAllJobs = async (req, res) => {
  try {
    const jobs = await Job.find().populate('postedBy', 'name email');
    res.status(200).json(jobs);
  } catch (err) {
    res.status(500).json({ error: 'Error fetching jobs' });
  }
};

export const applyForJob = async (req, res) => {
  try {
    const job = await Job.findById(req.params.id);
    if (!job) return res.status(404).json({ error: 'Job not found' });

    if (job.applicants.includes(req.user.id)) {
      return res.status(400).json({ error: 'Already applied' });
    }

    job.applicants.push(req.user.id);
    await job.save();
    res.status(200).json({ message: 'Applied successfully' });
  } catch (err) {
    res.status(500).json({ error: 'Error applying for job' });
  }
};


// ===== controllers/userController.js =====

import User from '../models/user.js';

// Create a new user (or any other item)
export const createUser = async (req, res) => {
  const { name, email, password  } = req.body;
  try {
    const newUser = new User({ name, email, password });
    await newUser.save();
    res.status(201).json({ message: 'User created successfully', user: newUser });
  } catch (err) {
    res.status(500).json({ error: 'Failed to create user' });
  }
};




// ===== models/Job.js =====

import mongoose from 'mongoose';

const jobSchema = new mongoose.Schema({
  title: String,
  description: String,
  location: String,
  salary: String,
  postedBy: { type: mongoose.Schema.Types.ObjectId, ref: 'User' }, // Admin
  applicants: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }], // Users who applied
}, { timestamps: true });

export default mongoose.model('Job', jobSchema);


// ===== models/user.js =====

// models/user.js
import mongoose from 'mongoose';

const userSchema = new mongoose.Schema({
  name: { type: String, required: true },
  email: { type: String, unique: true, required: true },
  password: { type: String, required: true },
  role: {
    type: String,
    enum: ['admin', 'user'], // âœ… 'user' must be here
    default: 'user'
  }
});

export default mongoose.model('User', userSchema);


// ===== routes/adminRoutes.js =====

// routes/adminRoutes.js
import express from 'express';
import { getAllUsers, updateUser, deleteUser } from '../controllers/adminController.js';
import { verifyToken, isAdmin } from '../middleware/authMiddleware.js';

const router = express.Router();

// Admin-only access
router.get('/', verifyToken, isAdmin, getAllUsers);
router.put('/:id', verifyToken, isAdmin, updateUser);
router.delete('/:id', verifyToken, isAdmin, deleteUser);

export default router;


// ===== routes/authRoutes.js =====

import express from 'express';
import { register, login } from '../controllers/authController.js';

const router = express.Router();

router.post('/register', register);
router.post('/login', login);

export default router;


// ===== routes/jobRoutes.js =====

import express from 'express';
import { postJob, getAllJobs, applyForJob } from '../controllers/jobController.js';
import { verifyToken, isAdmin } from '../middleware/authMiddleware.js';

const router = express.Router();

router.get('/', verifyToken, getAllJobs);             // Anyone can see all jobs
router.post('/', verifyToken, isAdmin, postJob);       // Only admin can post
router.post('/apply/:id', verifyToken, applyForJob);   // User applies to job

export default router;


// ===== routes/resumeRoutes.js =====

import express from 'express';
import { generateAndDownloadResume } from '../controllers/generateResumeController.js';
import { verifyToken } from '../middleware/authMiddleware.js';

const router = express.Router();

// POST /api/resume/download
router.post('/download', verifyToken, generateAndDownloadResume);

export default router;


// ===== routes/userRoutes.js =====

import express from 'express';
import { createUser } from '../controllers/userController.js';
const router = express.Router();

router.post('/', createUser); // POST /api/users



export default router;


// ===== config/db.js =====

import mongoose from "mongoose";

const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URI);
    console.log('MongoDB connected successfully');
  } catch (error) {
    console.error('MongoDB connection error:', error.message);
    process.exit(1);
  }
};

export default connectDB;

// ===== server.js =====

import express from "express";
import dotenv from "dotenv";
dotenv.config();
// import User from '../models/User.js';   

const app = express();

import authRoutes from './routes/authRoutes.js';

import cors from "cors";    
import connectDB from "./config/db.js";
connectDB(); 

// Middleware
app.use(cors());
app.use(express.json());

import userRoutes from './routes/userRoutes.js';

import adminRoutes from './routes/adminRoutes.js';

import resumeRoutes from './routes/resumeRoutes.js';

import jobRoutes from './routes/jobRoutes.js';
app.use('/api/jobs', jobRoutes);
app.use('/api/resume', resumeRoutes);
app.use('/api/users', userRoutes);
app.use('/api/auth', authRoutes);
app.use('/api/admin', adminRoutes);


// Basic Route
app.get('/', (req, res) => {
  res.send('Time Pro API is running...');
});


// Start Server
const PORT = process.env.PORT ;
app.listen(PORT, () => console.log(` Server running on port ${PORT}`));
