

// ===== controllers/adminController.js =====

import User from '../models/user.js';
import Job from "../models/Job.js";
import Application from "../models/applicationModel.js";


// Create a new user (or any other item)
export const createUser = async (req, res) => {
  const { name, email, password  } = req.body;
  try {
    const newUser = new User({ name, email, password });
    await newUser.save();
    res.status(201).json({ message: 'User created successfully', user: newUser });
  } catch (err) {
    res.status(500).json({ error: 'Failed to create user' });
  }
};

// Get all users (Admin only)
export const getAllUsers = async (req, res) => {
  try {
    const users = await User.find().select('-password'); // Exclude password
    res.status(200).json(users);
  } catch (err) {
    res.status(500).json({ error: 'Failed to fetch users' });
  }
};

// Update a user by ID (Admin only)
export const updateUser = async (req, res) => {
  const { id } = req.params;
  const { name, email, role } = req.body;

  try {
    const updatedUser = await User.findByIdAndUpdate(
      id,
      { name, email, role },
      { new: true, runValidators: true }
    ).select('-password');

    if (!updatedUser) {
      return res.status(404).json({ error: 'User not found' });
    }

    res.status(200).json(updatedUser);
  } catch (err) {
    res.status(500).json({ error: 'Failed to update user' });
  }
};

// Delete a user by ID (Admin only)
export const deleteUser = async (req, res) => {
  const { id } = req.params;

  try {
    const deletedUser = await User.findByIdAndDelete(id);

    if (!deletedUser) {
      return res.status(404).json({ error: 'User not found' });
    }

    res.status(200).json({ message: 'User deleted successfully' });
  } catch (err) {
    res.status(500).json({ error: 'Failed to delete user' });
  }
};

export const getDashboardStats = async (req, res) => {
  try {
    const totalUsers = await User.countDocuments();
    const totalJobs = await Job.countDocuments();
    const totalApplications = await Application.countDocuments();

    res.status(200).json({
      totalUsers,
      totalJobs,
      totalApplications,
    });
  } catch (error) {
    console.error("Dashboard Stats Error:", error);
    res.status(500).json({ error: "Failed to fetch dashboard stats" });
  }
};


// ===== controllers/applicationController.js =====

// controllers/applicationController.js
import Application from '../models/applicationModel.js';
import Job from '../models/Job.js';

export const applyForJob = async (req, res) => {
  try {
    const { message, resumeUrl } = req.body;
    const jobId = req.params.id;
    const userId = req.user.id;

    const existingApp = await Application.findOne({ job: jobId, applicant: userId });
    if (existingApp) {
      return res.status(400).json({ error: "You already applied for this job." });
    }

    const application = await Application.create({
      job: jobId,
      applicant: userId,
      resumeUrl,
      message,
    });

    res.status(201).json({ message: "Application submitted", application });
  } catch (err) {
    console.error("Apply error:", err);
    res.status(500).json({ error: "Failed to apply for job" });
  }
};

export const getAllApplications = async (req, res) => {
  try {
    const applications = await Application.find()
      .populate('applicant', 'name email')
      .populate('job', 'title');

    res.status(200).json(applications);
  } catch (err) {
    res.status(500).json({ error: "Failed to fetch applications" });
  }
};

export const updateApplicationStatus = async (req, res) => {
  const { status } = req.body;
  const { id } = req.params;

  try {
    const application = await Application.findByIdAndUpdate(
      id,
      { status },
      { new: true }
    );

    if (!application) {
      return res.status(404).json({ error: "Application not found" });
    }

    res.status(200).json({ message: "Status updated", application });
  } catch (err) {
    res.status(500).json({ error: "Failed to update application" });
  }
};


// ===== controllers/auth.js =====

import jwt from 'jsonwebtoken';

export const login = async (req, res) => {
  const { email, password } = req.body;
  const user = await User.findOne({ email });

  // password check skipped for brevity

  const token = jwt.sign(
    { id: user._id, role: user.role },     // payload
    process.env.JWT_SECRET,               // secret key
    { expiresIn: '7d' }                   // optional: token expiry
  );

  res.status(200).json({
    token,
    role: user.role,
    user: { id: user._id, name: user.name }
  });
};


// ===== controllers/authController.js =====

// controllers/authController.js
import User from '../models/user.js';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';

export const register = async (req, res) => {
  const { name, email, password, role } = req.body;

  try {
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ error: 'Email already exists' });
    }

    const hashedPassword = await bcrypt.hash(password, 10);
    const user = await User.create({ name, email, password: hashedPassword, role });

    res.status(201).json({ message: 'Registration successful' });
  } catch (err) {
    console.error('Register error:', err.message); // âœ… Add this line for debugging
    res.status(500).json({ error: 'Server error' }); // âœ… Keep this response
  }
};



export const login = async (req, res) => {
  try {
    const { email, password } = req.body;

    if (!email || !password) {
      return res.status(400).json({ error: 'Email and password are required' });
    }

    const user = await User.findOne({ email });
    if (!user || !(await bcrypt.compare(password, user.password))) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    const token = jwt.sign(
      { id: user._id, role: user.role },
      process.env.JWT_SECRET,
      { expiresIn: '1d' }
    );

    res.status(200).json({
      message: 'Login successful',
      token
    });
  } catch (err) {
    console.error('Login error:', err); // ðŸ‘ˆ Helpful for debugging
    res.status(500).json({ error: 'Login failed' });
  }
};


// ===== controllers/generateResumeController.js =====

// controllers/generateResumeController.js
"use server";
import dotenv from "dotenv";
dotenv.config();
import PDFDocument from 'pdfkit';
import { OpenAI } from 'openai';

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

export const generateAndDownloadResume = async (req, res) => {
  const { name, email, skills, experience, education } = req.body;

  if (!name || !skills || !experience || !education) {
    return res.status(400).json({ error: 'Missing required fields' });
  }

  const prompt = `Create a professional resume for:
  Name: ${name}
  Email: ${email}
  Skills: ${skills.join(', ')}
  Experience: ${experience}
  Education: ${education}`;

  try {
    const completion = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [{ role: 'user', content: prompt }],
      temperature: 0.7,
    });

    const resumeText = completion.choices[0].message.content;

    const filename = `resume_${name.replace(/\s+/g, '_')}.pdf`;
    res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
    res.setHeader('Content-Type', 'application/pdf');

    const doc = new PDFDocument();
    doc.pipe(res);
    doc.fontSize(12).text(resumeText, { align: 'left' });
    doc.end();
  } catch (error) {
    console.error('Resume generation error:', error);

    if (error.status === 429 || error.code === 'insufficient_quota') {
      // fallback resume content
      const fallbackResume = `Resume for ${name}
Email: ${email}
Skills: ${skills.join(', ')}
Experience: ${experience}
Education: ${education}`;

      const filename = `resume_${name.trim().replace(/[^a-zA-Z0-9]/g, '_')}.pdf`;
      res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
      res.setHeader('Content-Type', 'application/pdf');

      const doc = new PDFDocument();
      doc.pipe(res);
      doc.fontSize(12).text(fallbackResume, { align: 'left' });
      doc.end();
    } else {
      res.status(500).json({ error: 'Failed to generate resume' });
    }
  }
};


const generateResumePDF = (req, res) => {
  const { name, email, skills, experience, education } = req.body;

  const doc = new PDFDocument();
  res.setHeader("Content-Type", "application/pdf");
  res.setHeader("Content-Disposition", "attachment; filename=resume.pdf");

  doc.pipe(res);

  doc.fontSize(20).text(`Resume for ${name}`, { underline: true });
  doc.moveDown();
  doc.fontSize(14).text(`Email: ${email}`);
  doc.moveDown();
  doc.text(`Skills: ${skills}`);
  doc.moveDown();
  doc.text(`Experience: ${experience}`);
  doc.moveDown();
  doc.text(`Education: ${education}`);

  doc.end();
};

export default generateResumePDF;

// ===== controllers/jobController.js =====

import Job from '../models/Job.js';

export const postJob = async (req, res) => {
  try {
    const job = await Job.create({ ...req.body, postedBy: req.user.id });
    res.status(201).json(job);
  } catch (err) {
    res.status(500).json({ error: 'Server error while posting job' });
  }
};

export const getAllJobs = async (req, res) => {
  try {
    const jobs = await Job.find().populate('postedBy', 'name email');
    res.status(200).json(jobs);
  } catch (err) {
    res.status(500).json({ error: 'Error fetching jobs' });
  }
};

export const applyForJob = async (req, res) => {
  try {
    const job = await Job.findById(req.params.id);
    if (!job) return res.status(404).json({ error: 'Job not found' });

    if (job.applicants.includes(req.user.id)) {
      return res.status(400).json({ error: 'Already applied' });
    }

    job.applicants.push(req.user.id);
    await job.save();
    res.status(200).json({ message: 'Applied successfully' });
  } catch (err) {
    res.status(500).json({ error: 'Error applying for job' });
  }
};


// ===== models/Job.js =====

import mongoose from 'mongoose';

const jobSchema = new mongoose.Schema({
  title: String,
  description: String,
  location: String,
  salary: String,
  postedBy: { type: mongoose.Schema.Types.ObjectId, ref: 'User' }, // Admin
  applicants: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }], // Users who applied
}, { timestamps: true });

export default mongoose.model('Job', jobSchema);


// ===== models/applicationModel.js =====

// models/applicationModel.js

import mongoose from "mongoose";

const applicationSchema = new mongoose.Schema(
  {
    job: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Job",
      required: true,
    },
    applicant: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    resumeUrl: {
      type: String, // if you're storing a resume file or link
    },
    status: {
      type: String,
      enum: ["pending", "approved", "rejected"],
      default: "pending",
    },
    message: {
      type: String, // optional message from applicant
    },
  },
  { timestamps: true }
);

const Application = mongoose.model("Application", applicationSchema);
export default Application;


// ===== models/user.js =====

// models/user.js
import mongoose from 'mongoose';

const userSchema = new mongoose.Schema({
  name: { type: String, required: true },
  email: { type: String, unique: true, required: true },
  password: { type: String, required: true },
  role: {
    type: String,
    enum: ['admin', 'user'], // âœ… 'user' must be here
    default: 'user'
  }
});

export default mongoose.model('User', userSchema);


// ===== routes/adminRoutes.js =====

// routes/adminRoutes.js
import express from 'express';
import { getAllUsers, updateUser, deleteUser } from '../controllers/adminController.js';
import { verifyToken, isAdmin } from '../middleware/authMiddleware.js';
import { getDashboardStats } from "../controllers/adminController.js";


const router = express.Router();

// Admin-only access
router.get('/', verifyToken, isAdmin, getAllUsers);
router.put('/:id', verifyToken, isAdmin, updateUser);
router.delete('/:id', verifyToken, isAdmin, deleteUser);
router.get("/dashboard-stats", verifyToken, isAdmin, getDashboardStats);

export default router;



// ===== routes/applicationRoutes.js =====

// routes/applicationRoutes.js
import express from "express";
import { applyForJob, getAllApplications, updateApplicationStatus } from "../controllers/applicationController.js";
import { verifyToken, isAdmin } from "../middleware/authMiddleware.js";

const router = express.Router();

router.post("/apply/:id", verifyToken, applyForJob);         // Apply to job
router.get("/", verifyToken, isAdmin, getAllApplications);   // Admin: view all
router.put("/:id", verifyToken, isAdmin, updateApplicationStatus); // Admin: change status

export default router;


// ===== routes/authRoutes.js =====

import express from 'express';
import { register, login } from '../controllers/authController.js';

const router = express.Router();

router.post('/register', register);
router.post('/login', login);

export default router;


// ===== routes/jobRoutes.js =====

import express from 'express';
import { postJob, getAllJobs, applyForJob } from '../controllers/jobController.js';
import { verifyToken, isAdmin } from '../middleware/authMiddleware.js';

const router = express.Router();

router.get('/', verifyToken, getAllJobs);             // Anyone can see all jobs
router.post('/', verifyToken, isAdmin, postJob);       // Only admin can post
router.post('/apply/:id', verifyToken, applyForJob);   // User applies to job

export default router;


// ===== routes/resumeRoutes.js =====

import express from 'express';
import { generateAndDownloadResume } from '../controllers/generateResumeController.js';
import { verifyToken } from '../middleware/authMiddleware.js';

const router = express.Router();

// POST /api/resume/download
router.post('/', verifyToken, generateAndDownloadResume);

export default router;


// ===== routes/userRoutes.js =====

import express from 'express';
import { createUser } from '../controllers/adminController.js';
const router = express.Router();

router.post('/', createUser); // POST /api/users



export default router;


// ===== config/db.js =====

import mongoose from "mongoose";

const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URI);
    console.log('MongoDB connected successfully');
  } catch (error) {
    console.error('MongoDB connection error:', error.message);
    process.exit(1);
  }
};

export default connectDB;

// ===== server.js =====

import express from "express";
import dotenv from "dotenv";
dotenv.config();
// import User from '../models/User.js';   

const app = express();

import authRoutes from './routes/authRoutes.js';

import cors from "cors";    
import connectDB from "./config/db.js";
connectDB(); 

// Middleware
app.use(cors());
app.use(express.json());

import userRoutes from './routes/userRoutes.js';

import adminRoutes from './routes/adminRoutes.js';

import resumeRoutes from './routes/resumeRoutes.js';

import jobRoutes from './routes/jobRoutes.js';

import applicationRoutes from './routes/applicationRoutes.js';

app.use('/api/applications', applicationRoutes);
app.use('/api/jobs', jobRoutes);
app.use('/api/resume', resumeRoutes);
app.use('/api/users', userRoutes);
app.use('/api/auth', authRoutes);
app.use('/api/admin', adminRoutes);


// Basic Route
app.get('/', (req, res) => {
  res.send('Time Pro API is running...');
});


// Start Server
const PORT = process.env.PORT ;
app.listen(PORT, () => console.log(` Server running on port ${PORT}`));
